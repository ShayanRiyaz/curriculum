<!--title={Parsing the File:Coding the Relationships Part 2}-->

<!--badges={Python:11,Algorithms:5}-->

<!--concepts={directedGraphs, introToGraphs, useOfGraphs}-->

Now that we have isolated the folder numbers, we will have to figure out how to organize our edges, maintaining our numbering heiarchy.

**Step 1: Store the edges of the directed graph** 

To find and store the edges for later use, we can slice the structural string to everything but the last character. Notice how this new sliced string is the structural character of the parent of the current one. We are going to represent each individual edge as a tuple, and all the edges as a list. Here we make one edge, store it as a tuple, and add it to the list:

```python
	aTuple = (dirAndVal[0][:-1], dirAndVal[0])
	edges.append(aTuple)
```

**Step 2: Handle edge cases**

Remember to check to check your **edge cases**!

```python
	if(dirAndVal[0] != "0"):
```

Why is the above good for handling edge case? What is that edge case? I'll give you a hint: its purpose lies in the following line.

```python
aTuple = (dirAndVal[0][:-1], dirAndVal[0])
```

Here, we are forming a tuple whose first element represents a parent and the whose second element represents a child of the parent. We do this by separating the last number in the directory number from the rest of the directory number in order to clearly see the parent number. For example, `0123` is a subfolder of `012`. Thus,

* `dirAndVal[0][:-1]` would return `012`, the parent (subfolder) number
* `dirAndVal[0]` would return `0123`, the child number

`aTuple` would then be `(012, 0123)`.

Now, once again, let's return to why our edge case check is necessary. If we are processing the root, (represented by `0`)

* `dirAndVal[0][:-1]` would return nothing
* `dirAndVal[0]` would return `0`

Our `aTuple` would be confusing, as the first element would be empty! Thus, since the root is a special exception (it has no parent), we do not want to create `aTuple` for it.