<!---title{print_ordered_file_structure() Function Part 2 Explained}--->

<!--badges={Python:18,Algorithms:18}-->

<!--concepts={directedGraphs, introToGraphs, useOfGraphs, Depth First Search (DFS), Stack Manipulation}-->

Lets begin by obtaining our new `start` and writing the appropriate information about it to the file. 

**Step 1: Iterate through the `stack` until it's empty**

In order to visit all of the nodes at least once, we need to keep going until the `stack` is empty:

```python
while stack: 
```
**Step 2: Pop the last node from `stack` to visit other nodes**

Now, we need a new vertex to visit. In order to do that, we just need to pop the last value off of the `stack` and save it in `start`:

```python
start = stack.pop()
```
**Step 3: Write to a new file**

We need to write all of the information associated with `start` to a new file:

```python
f = open("output.txt", "a")
```
The second parameter is `a` to signify that we are appending to the file.

**Step 4: Replicate the structure of the original file**

We are now writing the correct information to the file here. `start` holds the identifier for a particular node. We know that we have the "file names" in the `val_map` so we use those as well to replicate the structure of the file we were originally given:

```python
f.write(start+'. ' + self.val_map[start] + '\n')
```
**Step 5: Close your newly made file after opening it**

Even though we are coming back to this file to work on it later, it is good practice to always close the file after opening it:

```python
f.close()
```

Here is the above code fragments shown together:

```python
while stack:
  start = stack.pop()
  f = open("output.txt", "a")
  f.write(start+'. ' +   self.val_map[start] + '\n')
  f.close()
```

At this point, we have saved the node that we are currently observing into `start`. Once we get this node, we are writing its information to the output file. Think about what more is required for us to do. 