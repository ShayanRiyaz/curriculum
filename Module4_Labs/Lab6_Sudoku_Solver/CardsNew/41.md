<!--title={Working within a square: findPossible()}-->

<!--badges={Algorithmns:18}-->

<!--concepts{Indexing 2D Lists}-->

# findPossible() Function

The first step is to confirm that the current square we are on is the number '0'. Otherwise we do not need to find possible values for it as it has been filled already. 

If `grid[r_i][c_i]` does not equal 0, then the square already has a value... so we don't need to find possible values for it! Therefore, we will simply just return an empty list to indicate that there are no possible values for our current square (`r_i`, `c_i`):

#### After checking if the square has a value...

We know that we can fill in the empty square if we deduce that it cannot be any of the values that are within the same box, row, or column. Thus we will search through those areas respectively and eliminate those values. Similar to our implementation of `box()`, we can build a list called `possible` which will hold values from 0 to 9. As we search through the rows, columns and within out box, we will remove values in `possible` that are found. 

#### Now iterate through the array by row and column

Given that we have `r_i` and `c_i` which is the location of our square, we can use this information to iterate through the same row, column, and box to search for values using a for-loop. 

We will have a total of 4 for-loops. 

* One for-loop to search through all the values in the same row 
* one for-loop to search through all the values in the same column
* two for-loops to search through all the values within the same box as our square. This will be the structure of the necessary for-loops:

#### Check the range of our box

Notice that for the nested for-loop needed to search for our box, we can use `range(0+r_i//3*3, r_i//3*3+3)` and  `range(0+c_i//3*3, c_i//3*3+3)` which allows us to check all of the elements within our box. 
