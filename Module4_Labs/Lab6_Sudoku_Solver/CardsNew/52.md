<!--title={checking by number (row, col, box): nextMove()}-->

<!--badges={Algorithmns:6}-->

<!--concepts{Functions}-->

# nextMove()

Now onto our second clause where we will check by number. This segment of our function will be broken down into three parts where we will evaluate by column, row, and box. For each of the possible numbers in Sudoku, we will loop through values 0 to 9 and checking to see if that value is possible (by using `findPossible()`  to check) as we check by row, column and box. So first we will need to check that `foundMove` is `False`, and if so we want to iterate through all the possible moves.

Now here are some hints for our 3 conditions within this clause:

- 1) Check by row: 

  - This will consist of a nested for-loop iterating through rows to check if any empty square can possibly be replaced with one value, from 0 to 9.

  - If so then you will store the row-column pair of that square and assign it the current number.

    > Note: if the current number `n` exists within the list returned from `findPossible() `, then we will append the row, column pair (`r_i`, `c_i`) into the initially empty list `m`.

- 2) Check by column: 

  - This will consist of a nested for-loop iterating through columns to check if any empty square can possibly be replaced with one value, from 0 to 9. 

  - If so then you will store the row-column pair of that square and assign it the current number.

  - The basic structure for this check will look like below

    > Note: if the current number `n` exists within the list returned from `findPossible() `, then we will append the row, column pair (`r_i`, `c_i`) into the initially empty list `m`.
  
- 3) Check by box: 

  - This will consist of two nested for-loops: 

    - The first nested for-loop to iterate through all the squares within a single box to discover if the current number is a possible value that does not yet exist within the box (via `box()`).
    - If the current number is one possible value (from 0 to 9), within the square for that box, the second nested for-loop will iterate through all the squares within that same box and use `findPossible()` to determine if the current number is still a valid possibility to fill in the empty square.

    > Note: if the current number `n` exists inside the box `b` returned from `box()`, the next nested for-loop will check if `n` exists within the list returned from `findPossible() `, then we will append the row, column pair (`r_i`, `c_i`) into the initially empty list `m`.


