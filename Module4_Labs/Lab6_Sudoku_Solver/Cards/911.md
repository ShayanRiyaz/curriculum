<!--title={user input: main() part 2}-->

<!--badges={Algorithmns:21}-->

<!--concepts{User Input}-->

# main() Part 2

First we will initialize our timers to 0. This will be our starting time which is represented by `time1`:

```python
time1 = 0
```

Then, we can proceed to ask the user to enter one of the options and accept their input as `c`:

```python
time1 = 0

c = input("Controls:\n\t'Enter': Display the next move\n\t'p': Print the current grid (small)\n\t'c': Complete the grid (or attempt to)\n\t'(r,c)': Prints the possible options for that row, column\n")
```

That string is a mouthful! The `\n` and `\t` are to make the string readable on *output*. Here's how it will actually look on the screen:

```
Controls:
				'Enter': Display the next move
				'p': Print the current grid (small)
				'c': Complete the grid (or attempt to)
				'(r,c)': Prints the possible options for that row, column
```

Now since the user has the option to progressively solve the Sudoku solver one move at a time or just let it complete itself, we have to condition on a while-loop that checks `hasMoves()` and determines if the user entered a valid option:

```python
time1 = 0

c = input("Controls:\n\t'Enter': Display the next move\n\t'p': Print the current grid (small)\n\t'c': Complete the grid (or attempt to)\n\t'(r,c)': Prints the possible options for that row, column\n")
while hasMoves(grid) and (len(c) == 0 or c == "p" or c == "c" or c[0] == "("):
```

Then we will have a series of if/elif/else statements that are determining what options what chosen by the user and to handle their request with the appropriate operation:

```python
time1 = 0

c = input("Controls:\n\t'Enter': Display the next move\n\t'p': Print the current grid (small)\n\t'c': Complete the grid (or attempt to)\n\t'(r,c)': Prints the possible options for that row, column\n")
while hasMoves(grid) and (len(c) == 0 or c == "p" or c == "c" or c[0] == "("):
	if c == "p":
		# print the current grid
	elif c == "c":
		# attempt to complete the grid
	elif len(c) > 0 and c[0] == "(":
		# print the possible options for that (row, column)
	else:
		# display the next move
    
```

For the while loop condition where `len(c) == 0` is checked for, this is because if the user presses the `enter` key in order to display the next move. The `enter` key is actually not stored as a character and instead is of length 0 which implies that `enter` was pressed.

For the second `elif`, we check if `len(c) > 0 and c[0] == "("` in order to determine if the user inputted a row, column pair. That's the only option where `c` would have a greater length than one character AND the first element in `c` must be equal to `(`. 

The other cases for `p` and `c` are simple cases of string compares to determine what the user requested respectively.

Remember that since the user can potentially work through the Sudoku puzzle one move at a time (via pressing `enter`), then we must continue looping to accept their next user input request for whatever operation they want to perform. Thus we must check if the `grid` is finished, if not we will provide the user with the controls again and await for their next input. Else, the `grid` is completed.

```python
time1 = 0

c = input("Controls:\n\t'Enter': Display the next move\n\t'p': Print the current grid (small)\n\t'c': Complete the grid (or attempt to)\n\t'(r,c)': Prints the possible options for that row, column\n")
while hasMoves(grid) and (len(c) == 0 or c == "p" or c == "c" or c[0] == "("):
	if c == "p":
		# Implement logic to print the current grid
	elif c == "c":
		# Implement logic to attempt to complete the grid
	elif len(c) > 0 and c[0] == "(":
		# Implement logic to print the possible options for that (row, column)
	else:
		# Implement logic to display the next move
  if hasMoves(grid):
		c = input("Controls:\n\t'Enter': Display the next move\n\t'p': Print the current grid (small)\n\t'c': Complete the grid (or attempt to)\n\t'(r,c)': Prints the possible options for that row, column\n")
  else:
    # Implement logic for when grid is complete!
```

For the case that the user enters `p` to print the grid, we simply just call the function we have already created to print the grid (`printGrid()`)!

```python
	if c == "p":
		printGrid(grid)
```

For the case that the user enters `c` to complete the grid, we will start the timer on `time1` and call the function we have created to complete the grid (`complete()`). However, the call to complete the grid must be conditioned in the case that the grid cannot be finished. Thus we will prompt the user with this print statement: `"Failed to complete. Please improve algorithm. :)"`

```python
	elif c == "c":
		time1 = time.time()
		if not complete(grid):
			print("Failed to complete.  Please improve algorithm. :)")
			#break
```

For the case that the user enters a row, column pair (`(r, c)`) we need print the possible options for that square. To do this, we will simply print the result from `findPossible()` on the row, column pair the user specified.

```python
	elif len(c) > 0 and c[0] == "(":
		print(findPossible(int(c[1])-1,int(c[3])-1,grid))
```

We do an `int` type cast to ensure that the `findPossible` function can use the actual integer value of the input. We subtract 1 from `int(c[1])` and `int(c[3])` respectively because `findPossible`'s parameters are *indices* (indexing starts at 0!) and the user entered row and column numbers, whose counting starts from 1. 

For the last case where the user enters `enter`, we will just call `nextMove()` to get the next move for the user!

```python
	else:
		nextMove(grid)
```

Now we have implemented the majority of our input handling for procedurally operating through the Sudoku solver. As of now, this is what part 2 of our input handling looks like:

```python
time1 = 0

c = input("Controls:\n\t'Enter': Display the next move\n\t'p': Print the current grid (small)\n\t'c': Complete the grid (or attempt to)\n\t'(r,c)': Prints the possible options for that row, column\n")
while hasMoves(grid) and (len(c) == 0 or c == "p" or c == "c" or c[0] == "("):
	if c == "p":
		printGrid(grid)
	elif c == "c":
		time1 = time.time()
		if not complete(grid):
			print("Failed to complete.  Please improve algorithm. :)")
			#break
	elif len(c) > 0 and c[0] == "(":
		print(findPossible(int(c[1])-1,int(c[3])-1,grid))
	else:
		nextMove(grid)
  if hasMoves(grid):
		c = input("Controls:\n\t'Enter': Display the next move\n\t'p': Print the current grid (small)\n\t'c': Complete the grid (or attempt to)\n\t'(r,c)': Prints the possible options for that row, column\n")
  else:
    # Implement logic for when grid is complete!
```

Now all we have left to implement is the else statement for when the grid is complete (when `hasMoves(grid)` evaluates to false).

