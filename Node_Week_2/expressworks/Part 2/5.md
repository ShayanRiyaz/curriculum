<<<<<<< Updated upstream
<!--title={Param Pam Pam}--> 

This exercise is about using URL parameters! Oftentimes, URLs are more than just the route of the page. They can also give your page values that wouldn't be available otherwise. 

For example, if a URL is `/message/:526aa677a8ceb64569c9d4fb`, the route is `/message/`, and `/526aa677a8ceb64569c9d4fb` is the parameter. In this case, that long string is the id of the message, but the parameter could be any variable you want to pass in. 
=======
<!--title={Extracting Parameters from the URL}-->

In this tutorial, we be creating an Express.js server that processes PUT `/message/:id` requests
and produces a SHA-1 hash of the current date combined with the ID from the URL.

Some background information:  An SHA-1 (Secure Hash Algorithm 1) is a cryptographic hash function which takes an input and produces a hash value known as a message digest. This message is a way to securly store data.

For this express server, we want it to take in a PUT request and securly convert into into SHA-1 hash, and then combine that hash value with the current date and the ID from the URL.

So, for instance, if the server receives
>>>>>>> Stashed changes


<<<<<<< Updated upstream

We're going to utilize URL parameters, creating an Express.js server that processes PUT requests. To start, let's require our modules. 

```js
const express = require('express')
const app = express()
```

The way to access the id in a route is using the format `/message/:id` . We already know how to create a PUT request for an app, so we just have to put them together.  

```js
app.put('/message/:id', function(req, res){
  const id = req.params.id
  ...
})
```

In the second line, we're getting our id! You can use a `console.log()` to double check the value of the id!

![image](https://images.pexels.com/photos/1181675/pexels-photo-1181675.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500)
=======
it should respond with a hash of the current date (as a string) and the ID. The URL above is a very common pattern in Restful APIs.  ``PUT`` is what the API is doing with the data (putting it somewhere, as opposed to ``DELETE``, which deletes the data, or ``GET``, which gets the data). The string of letters and numbers after ``/message/`` is the object ID. 

As always, we will first start by creating a new file, here called ``param.js``. Then, import the dependencies:

``````javascript
const express = require('express') // the dependency is the express framework itself
``````

Next, we will create the Express app:

```javascript
const app = express()
```

Once we have created the app, we will then tell express to look for the message ID. We will do this by instructing the app to use the put method (which updates the data (as opposed to the get, post or delete methods)).

`app` handles PUT requests in any subdirectory of `/path/`:
>>>>>>> Stashed changes

Our function should also *hash* the id, so that hackers can't use the data. Let's add a SHA-1 hash. 

**SHA-1** stands for Secure Hash Algorithm 1, and performs what is called a *message digest* on an input. The output of the message digest will be a converted value by a certain function. 

So, if the server receives a PUT request for `'/message/526aa677a8ceb64569c9d4fb'` it should respond with a hash of the current date (as a string) and the ID.



The SHA-1 can be computed like this:

```js
const str = require('crypto')
  .createHash('sha1')
  .update(new Date().toDateString() + id)
  .digest('hex')

<<<<<<< Updated upstream
res.send(str)
```



Great job, the final step is to have your app listen to the port on  `process.argv[2]`. 


=======
For our purposes, we will be giving the PUT reguest the path ``message``:

```javascript
app.put('/message/:id', function(req, res){/* ... */}
```

Notice the ``:`` after ``/message/``. This colon tells express.js that this is a parameter, and express.js will automatically pass the value from the URL so you can get the object. 

Since we want to extract the id from request handler, for  `req.params`, we will use the name `id`:

```javascript
const id = req.params.id //notice that params is plural. This means we can have more than one parameter
```

Now that we have the object ID, we can go ahead and compute the SHA-1 Hash. The SHA-1 can be computed like this:

```js
require('crypto') //The crypto module provides cryptographic functionality
  .createHash('sha1') //Creates and returns a Hash object that can be used to generate hash digests using the given algorithm
  .update(new Date().toDateString() + id) //Updates the hash content with the given data, in this case the current date and the message ID.
  .digest('hex') //Calculates the digest of all of the data passed to be hashed
//'hex' is how the digest is encoded

```

To finish up the function, use 

```javascript
res.send(str) //Sends the HTTP response
```

Finally, connect the file to a port by using the ``app.listen`` command.

```javascript
app.listen(3000)
```

The final code, once put together, should look like:

```javascript
const express = require('express')
const app = express()

app.put('/message/:id', function(req, res){
  const id = req.params.id
  const str = require('crypto')
    .createHash('sha1')
    .update(new Date().toDateString() + id)
    .digest('hex')
  res.send(str)
})

app.listen(3000)
```

To test our work, go to the terminal and type in:

```tex
nodemon param.js
```

Make sure the server is running, then go over to postman and submit a PUT request:
>>>>>>> Stashed changes

TODO: Add screenshot of postman