<!--title={Trees}-->

<!--badges={Algorithms:5,Python:5}-->

<!--concepts={The Node, Binary Search Trees}-->

We are going to learn about tree data structures. In order to do so, it is important that we understand the essential terminology.

#### Tree Terminology:

* **Tree**: Hierarchical structure used to store data elements.

* **Node**: Each individual data element of the tree that is linked to other data elements within the tree. Identified by a key.

* **Edge**: Link that connects two nodes.

* **Root Node**: The node with highest hierarchical precedence. Each tree can only have one root node.

* **Parent Node**: The predecessor of a node is called its parent. The root node does not have a parent.

* **Child Node**: The descendant of a node is called its child.

* **Sibling Nodes**: The nodes that have the same parent are called siblings.

* **Leaf Nodes**: A node that does not have a child is called a leaf.

* **Internal Nodes**: A node that has at least one child is called an internal node.

* **Subtree**: A grouping of connected nodes within the tree.

  <Img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/1200px-Binary_search_tree.svg.png" width="600">

In the tree above, the circles with numbers in them are the **nodes** of the tree. The arrows connecting each nodes are the **edges**. The **root** of this tree is the node that contains the number 8. The node containing 3 is a **parent** of the node containing 1. The node containing 1 is a **child** of the node containing 3. The nodes with 4 and 7 are **siblings**. The nodes with 1, 4, 7, and 13 are **leaf** nodes. The nodes containing 8, 3, 10, 6, and 14 are all **internal** nodes. Finally, the group of nodes with values 6, 4, and 7 are a **subtree** of the tree.

#### Real Life Application of Trees:

##### Ancestry Trees:

<img src="https://www.ancestrycdn.com/support/us/2017/11/family-1big.png" width="500">

You may be wondering why we would want to use trees. A real life example of a tree structure being used is in ancestry trees. Think of each person in the family as a node. Every person in the family tree is related to other people in the family in some way as a sibling, parent, grandparent, etc.. Tree data structures behave in a very similar way as they are both hierarchical structures with nodes, or family members, connected together in a certain manner, and the connection between nodes are there for a specific reason.

Now that we understand the structure of a tree and the common terminology used to describe elements of a tree, let's think of how we would implement the structure in Python.

#### The `Node` Class:

It may be tempting to declare a class called `Tree` in which we store all the nodes in the class. While this approach makes sense, it can often lead to confusion and does not have built-in functionality for relationships between the nodes in the tree. When you realize that a class for the tree itself is not necessary, you may think of a second approach, which is the standard implementation. Instead, for this implementation, we will declare a class `Node` in which in each instance of the class represents a node of the tree.  The `Node` class contains the data value of a node and a list of its children. Let's define the `Node` class:

```Python
class Node:
    def __init__(self, key):
        self.key = key
        self.children = []
    
    def insert_child(self, newChild):
        self.children.append(newChild)
```

This implementation of the `Node` class also includes an `insert_child` function that simply appends the node passed as an argument to the current node's list of children. Since each node has its children stored in it, the structure of the tree is maintained, making the `Tree` class unnecessary. You may be asking why we don't keep track of each node's parent. While this may be useful or necessary for some more advanced types of trees, it is not needed to implement a base tree that we're currently investigating.

#### Binary Search Trees:

A simple tree structure is fundamental, but let's investigate a specific type of tree that allows for an interesting and structured way to store data. A **Binary Search Tree (BST)** is a tree where every single node can only have zero, one, or two children. **BST**s also have a few more requirements.

##### BST Rules:

* Each node in the tree can have only 0, 1, or 2 children.

* Every node in the left subtree of a node has keys that are lower in number than the key of that particular node.

* Every node in the right subtree of a node has keys that are higher in number than the key of that particular node.

  

  Let's see an example of a valid vs invalid BST:

  <img src="https://i1.wp.com/algorithms.tutorialhorizon.com/files/2014/09/Invalid-BST.png?ssl=1" width="250">

  <img src="https://i0.wp.com/fitcoding.com/wp-content/uploads/2016/10/720px-Binary_search_tree.svg_.png" width="250">

  

Are you able to tell which tree is a valid BST and which is invalid?

The **top** tree is an **invalid** BST because the node containing the key 10 is in a right subtree of the node containing the key 30. You may have noticed that all subtrees of a BST are also BSTs.



In order to implement a BST in Python, we just need to adjust our previous `Node` class.

```Python
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.key = key
```

Since we know that BST nodes only have two children max, we no longer need a list to store the children; we simply store the left child as the **left** element and the right child as the **right** element. In the `Node` class the left and right children are initialized to null.

