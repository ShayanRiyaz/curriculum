<!--title={Python Decorators}-->

<!--badges={Software Engineering:15,Python:15}-->

<!--concepts={function_decorator.mdx}-->

# Python Decorators

**Decorators** are used to encapsulate lot of implementation details and leaving out very simple interface.

For example:

```python
@login_required
def edit_post(post_id):
    ...
```

`@login_required` is a decorator that makes sure that the user is logged in before they can edit a post. This decorator will redirect to a login page if the user is not logged in and then redirecting back to the same page after a successful login. The decorator is doing a lot, but notice how all the developer has to do is to add `@login_required` before the `edit_post()` function. 

The `@decorator` is just shorthand for something really simple.

```python
# Both are the same thing

# with decorators
@decorator
def func():
    <code>

# without decorators
def func():
    <code>
    
func = decorator(func)
```

Let's write a simple decorator to demonstrate this concept: 

```python
def trace(f):
    def g(x): 
        print(f.__name__, x) #__name__ is a built-in variable in python that allows you to access the name; in this case, we are accessing the name of our function.
        return f(x)
    return g
```

The `trace()` function takes in a function as argument and returns a new function that is just like the function we passed in, but prints the function name and argument for every call.

```python
@trace
def square(x):
    return x*x
    
@trace
def double(x):
    return x+x
    
print(square(4))
print(square(5))
print(double(4))
print(double(5))

## square 4 (trace is printing this out)
## 16 (our print function is printing this out)
## square 5
## 25
## double 4
## 8
## double 5
## 25
```

However, our current decorator only works with functions that takes in one argument; often, decorators are written to handle functions with any number of arguments, so let's do that by replacing `x` with `*args`, which is used to pass a variable number of arguments!

```python
def trace(f):
    def g(*args):
        print(f.__name__, args)
        return f(*args)
    return g
```

Now if we use our decorator:

```python
@trace
def square(x):
    return x*x
    
@trace
def sum_of_squares(x, y):
    return square(x) + square(y)
    
print(sum_of_squares(3, 4))

## sum_of_squares (3, 4)
## square (3,)
## square (4,)
## 25
```

The output may seem confusing as to what is going on, but with a little of work, we can make the output much clearer (note: do not try to understand the code below; the point is to understand decorators, so copy and paste the code and run it):

```python
level = 0
def trace(f):
    def g(*args):
        global level
        # pretty print indicating the level
        prefix = "|  " * level + "|--"
        strargs = ", ".join(repr(a) for a in args)
        print("{} {}({})".format(prefix, f.__name__, strargs))
        # increment the level before calling the function
        # and decrement it after the call
        level += 1
        result = f(*args)
        level -= 1
        return result
    return g
```

This will be the output as we run the code above:

```python
|-- sum_of_squares (3, 4)
|  |-- square (3,)
|  |-- square (4,)
25
```

