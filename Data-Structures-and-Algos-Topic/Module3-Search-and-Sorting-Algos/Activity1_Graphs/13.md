<!--title={Keys and Rooms Explanation}-->

<!--badges={Algorithms:15,Python:5}-->

<!--concepts={useOfGraphs, realLifeApplication, adjacencyList, depthFirstSearch}-->

## Keys and Rooms
### Explanation
The key (no pun intented, hehe) to solving this problem is recognizing that the rooms and keys can be represented as a graph, and the goal is to check whether or not every vertex in the graph can be reached (if every room can be entered).

### Breakdown - Three Steps
Let's break this puzzle into three discrete steps.

**Step 1: Create the Graph** <br>
The input is a list of lists, and we need to turn this into a graph. I have chosen to use the adjacency list to represent the graph, as it is intuitive to visualize. 

```python
  graph = {i:[] for i in range(len(rooms))}
  for j in range(len(rooms)):
    graph[j] = [key for key in rooms[j]]
```
> Creating the adjacency list via Python comprehensions ~ so elegant.

**Step 2: Traverse the Graph** <br>
We must traverse ```graph``` in order to find out whether or not each vertex (room) can be reached. Below is the recursive function ```dfs``` that implements the Depth-First Search algorithm for graph traversal. You will learn more about this in the next Activity.

```python
def dfs(visited, graph, vertex):
  if vertex not in visited:
    visited.add(vertex)
    for neighbour in graph[vertex]:
      dfs(visited, graph, neighbour)

  return visited
```
> Function to perform depth-first search ~ quite simple indeed.

Note that the function ```dfs``` takes in three parameters:
* ```visited```, a set which will keep track of which vertices (rooms) we have entered
* ```graph```, the graph to be traversed
* ```vertex```, the current vertex being visited

```dfs``` returns ```visited ``` after all reachable vertices have been reached. We will call it from inside ```canVisitRooms``` and assign its value to ```rooms_reached```, shown below.

```python
rooms_reached = dfs(set(), graph, 0)
```
> We pass an empty ```set```, ```graph```, and ```0``` since we start at room ```0```.

**Step 3: Return the Result** <br>
The final step is to check whether ```rooms_reached``` contains all the rooms we started withâ€”if so, then we were able to unlock each and every room. A simple comparison will do the trick.

```python
if list(rooms_reached) == list(range(0, len(rooms))): 
  return True
else: 
  return False
```
> Type-casting using ```list()``` is probably the easiest way to do this.

And that's it! Try passing an arbitrary input of the form ```[[keys], [keys],...]``` to test out your code.

Move on to the next card to see all the code in its glory!
