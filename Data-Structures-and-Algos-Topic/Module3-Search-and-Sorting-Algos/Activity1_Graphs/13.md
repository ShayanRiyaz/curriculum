<!--title={Keys and Rooms Explanation}-->

<!--badges={Algorithms:15,Python:5}-->

<!--concepts={useOfGraphs, realLifeApplication, adjacencyList, depthFirstSearch}-->

## Keys and Rooms
### Explanation
The key (no pun intented, hehe) to solving this problem is recognizing that the rooms and keys can be represented as a graph, and the goal is to check whether or not every vertex in the graph can be reached (if every room can be entered).

### Breakdown - Three Steps
Let's break this puzzle into three discrete steps.

**Step 1: Create the Graph**.
The input is a list of lists, and we need to turn this into a graph. I have chosen to use the adjacency list to represent the graph, as it is intuitive to visualize. 

```python
  graph = {i:[] for i in range(len(rooms))}
  for j in range(len(rooms)):
    graph[j] = [key for key in rooms[j]]
```
> creating adjacency list

**Step 2: Traverse the Graph**.
There are two main ways to traverse a graph: Depth-First Search and Breadth-First Search. You will learn about these algorithms in the next Activity, and this puzzle should be a good warm-up.

```python
def dfs(visited, graph, node):
  if node not in visited:
    visited.add(node)
    for neighbour in graph[node]:
      dfs(visited, graph, neighbour)

  return visited
```
> function to perform depth-first search 

As you can see above, the function ```dfs``` takes in three parameters:
<ul>
  <li>the ```set``` visited</li>
  <li></li>
  <li></li>
</ul>

```python
visited = dfs(set(), graph, 0)
```
> 

**Step 3: Return the Result**.


```python
# 2. dfs traverse the adjacency list
visited = dfs(set(), graph, 0)
```
