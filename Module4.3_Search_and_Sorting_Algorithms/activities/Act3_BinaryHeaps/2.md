<!--title={Binary Heap: Insert() and percUp()}-->

<!--badges={Algorithms:15,Python:5}-->

<!--concepts={Binary Search Tree Heap}-->

The next method we will implement is `insert`. The easiest, and most efficient, way to add an item to a list is to simply append the item to the end of the list. The good news about appending is that it guarantees that we will maintain the complete tree property. The bad news about appending is that we will very likely violate the heap structure property. However, it is possible to write a method that will allow us to regain the heap structure property by comparing the newly added item with its parent. If the newly added item is less than its parent, then we can swap the item with its parent. The figure below shows the series of swaps needed to percolate the newly added item up to its proper position in the tree:

![](https://runestone.academy/runestone/books/published/pythonds/_images/percUp.png)

> Figure 2: Percolate the New Node up to Its Proper Position



Notice that when we percolate an item up, we are restoring the heap property between the newly added item and the parent. We are also preserving the heap property for any siblings. Of course, if the newly added item is very small, we may still need to swap it up another level. In fact, we may need to keep swapping until we get to the top of the tree. 

Let's look at the `percUp` method, which percolates a new item as far up in the tree as it needs to go to maintain the heap property. 

We pass one argument, `i`, which is the size of the heap, because that index is where the new value is located. Then, we use a `while` loop, which simply checks that there are enough values in the heap to use this function. 

```python
def percUp(self,i):
    while i // 2 > 0:
```

Next, we enter the while loop. Here is where our wasted element in `heapList` is important. Notice that we can compute the parent of any node by using simple integer division. The parent of the current node can be computed by dividing the index of the current node by 2.

```python
      if self.heapList[i] < self.heapList[i // 2]:
         tmp = self.heapList[i // 2]
         self.heapList[i // 2] = self.heapList[i]
         self.heapList[i] = tmp
```

If the newly appended value, which is at index `i`, is less than the value at its parent node, then we begin the process of percolating the value up the heap. 

Lastly, we decrement `i` by dividing it by two, making it the location of the parent node, which is now where the newly appended value is located. Then this index is passed to the while loop again, so the value can keep percolating up as necessary.

```python
      i = i // 2
```

This is the completed method:

```python
def percUp(self,i):
    while i // 2 > 0:
      if self.heapList[i] < self.heapList[i // 2]:
         tmp = self.heapList[i // 2]
         self.heapList[i // 2] = self.heapList[i]
         self.heapList[i] = tmp
      i = i // 2
```



We are now ready to write the `insert` method (see below). Most of the work in the `insert` method is really done by `percUp`. Once a new item is appended to the tree, `percUp` takes over and positions the new item properly.

```python
def insert(self,k):
    self.heapList.append(k)
    self.currentSize = self.currentSize + 1
    self.percUp(self.currentSize)
```

